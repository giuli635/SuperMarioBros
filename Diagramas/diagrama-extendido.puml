@startuml
' TODO: crear los colisionadores de carga
' TODO: vincular los colisionadores de carga con el engine gráfico

together {
    class Game <<Singleton>> {
        #{static} uniqueInstance: Game
        #toUpdateRegistry: Set<Entity>
        #currNivel: Level
        #character: Character
        +{static} instance()
        #loadLevel()
        +registerToUpdate(e: Entity)
        +unregisterToUpdate(e: Entity)
        +{static} main()
    }

    class Level{
        #time: Duration
        #points: int
        +getPoints(): int
        +setPoints(points: int)
    }
    note left of Level::time
        Duration es la clase de Java
    end note

    class Menu <<Singleton>> {
        #{static} uniqueInstance: Menu
        +{static} instance()
        +selectMode(modo: int)
        +showModes()
        +showRanking()
        ' TODO: implementar la UI del menu
    }

    class Ranking <<Singleton>> {
        #rank: Map<String, Integer>
        #{static} uniqueInstance: Ranking
        +{static} instance()
        +addEntry(player: String, points: int)
        +getRanking(): Iterable<Entry<String, Integer>>
    }
}

together {
    class Character {
        #List<PowerUp>: activePowerUps
        #StrategyState: state
        +walk(d: Direction)
        +move()
        +crouch()
        +jump()
        +superJump()
        +die()
        +throwProyectile()
        +setState(state : State)
        +addPowerUp(pw: PowerUp)
        +applyPowerUp()
        +removePowerUp(pw: PowerUp)
        +receive(e: Enemy)
        +applyPowerUp()
    }
    note left of Character::aplicarEfecto
        cambia el state de mario 
    end note
    note left of Character::removePowerUp
        cuando se remueve el power up tambien se remueve el state de mario
    end note
    note left of Character::applyPowerUp
        se aplica cada power up en cada frame del juego segun sea necesario
    end note

    abstract class StrategyState{
        +receive(pw: PowerUp)
        +receive(pw: PowerUp, pw: PowerUp)
        +collideWithBlock(pw: PowerUp)
    }

    interface PowerUp {
        +activate(mario: Character)
        +deactivate(mario: Character)
    }
    note left of PowerUp::activate
      en cada clase concreta de PowerUp contiene la lógica específica de ese power-up
    end note

    interface CharacterState{
        +recieveDamage(character: Character)
    }

    class DefaultState{
    }

    class SuperState{
        +breakBlock(plataform: Plataform);
    }

    class FireFlowerState{
        +throwFireBall()
    }

    class Movable{
        +changeDirection()
    }

    interface Enemy { 
        +recieveDamage() 
        +die()
        +move() 
        +getPoints(): int
    }

    class KoopaTroopa {
        #shell: Shell
        #hidden: boolean
        +hide(bool: boolean)
        +show(): boolean

    } 

    class Goomba{
    }

    class Spiny { 
    }

    class Lakitu {
    }

    class BuzzyBeattle {
    }

    class PiranhaPlant {  
    }

    class Coin {
    }

    abstract class PowerUp {
        +apply(character: Character)
    }

    class FireFlower{
    }

    class GreenMushroom{
        +addLife()
    }

    class SuperMushroom{
    }

    class Star{
    }
    
    class Plataform {
    }

    class Void {
    }

    class Pipe {
        #piranha: PiranhaPlant
    }

    class SolidBlock {
    }

    class QuestionBlock {
        #coin: Coin
        #PowerUp: PowerUp
    }

    class SolidBrick {
        +break()
    }
    
    class Slider{
        +changeDirection()
    }

    class Shell{
    }

    class Proyectile{
    }

    class FireBall {
    }

}

together {
    class CollisionsEngine <<Singleton>> {
        #{static} uniqueInstance: CollisionsEngine
        #nextCollidersToCheck: Collection<Collider>
        #chunks: [][]Collection<Collider>
        +{static} instance()
        #checkCollision(e1: Collider, e2: Collider)
        +registerToCheck(c: Collider)
        +setChunk(c: Collider, x: int, y: int)
    }
    note left of CollisionsEngine::checkCollision
        if (hayColision) {
            c2.collide(c1, d1);
            c1.collide(c2, d2);
        }
    end note

    interface Entity {
        +update()
        +loaded(): boolean
        +load()
    }

    interface Collider {
        +getEntidad(): Entity
        +collide(c: Collider, d: Direction)
        +handleCollision(c: Collider, d: Direction)
        +getPosition(p: Position)
        +setPosition(): Position
        +switch(b: boolean)
        +activated(): boolean
    }
    note left of Collider::collide
        c.handleCollision(this, d)
    end note

    interface GraphicElement {
        +draw()
        +getPosition(): Position
        +setPosition(p: Position)
        +getSprite(): Sprite
        +setSprite(s: Sprite)
    }

    class SpriteFactory {
        #possibleSprites: Collection<String>
        #loadedSprites: Map<String, Sprite>
        +getSprite(key: String)
        +getPossibleSprites(): Iterable<String>
    }

    class Sprite {
        #imagen : Image
        +draw(int x, int y)
        +setImage(image : Image)
        +getImage() : Image
    }

    class GraphicEngine {
        #elements: Collection<GraphicElement>
        +addElementoGrafico(e: GraphicElement)
        +drawFrame()
    }

    class LevelReader <<Singleton>> {
        +createLevel(file: String): Level
    }

    class Position {
        #x: int
        #y: int
        +alterX(diff: int)
        +alterY(diff: int)
        +getX(): int
        +getY(): int
    }
}

enum Direction {
    LEFT
    RIGTH
    UP
    DOWN
}
@enduml
