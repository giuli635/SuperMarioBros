@startuml
' TODO: crear los colisionadores de carga
' TODO: vincular los colisionadores de carga con el engine gráfico

together {
    class Juego <<Singleton>> {
        #{static} uniqueInstance: Juego
        #toUpdateRegistry: Set<Entidad>
        #currNivel: Nivel
        #personaje: Personaje
        +{static} instance()
        #cargarNivel()
        +registerToUpdate(e: Entidad)
        +unregisterToUpdate(e: Entidad)
        +{static} main()
    }

    class Nivel{
        #tiempo: Duration
        #puntaje: int
        +getPuntaje(): int
        +setPuntaje(puntaje: int)
    }
    note left of Nivel::tiempo
        Duration es la clase de Java
    end note

    class Menu <<Singleton>> {
        #{static} uniqueInstance: Menu
        +{static} instance()
        +seleccionarModo(modo: int)
        +mostrarModos()
        +mostrarRanking()
        ' TODO: implementar la UI del menu
    }

    class Ranking <<Singleton>> {
        #rank: Map<String, Integer>
        #{static} uniqueInstance: Ranking
        +{static} instance()
        +agregarEntrada(jugador: String, puntaje: int)
        +getRanking(): Iterable<Entrada<String, Integer>>
    }
}

together {
    class Personaje {
        #List<PowerUp>: activePowerUps
        #StrategyState: state
        +caminar(d: Direccion)
        +mover()
        +agacharse()
        +saltar()
        +superSalto()
        +morir()
        +lanzarProyectil()
        +setEstado(estado : Estado)
        +agregarPowerUp(pw: powerUp)
        +aplicarPowerUps()
        +removerPowerUp(pw: powerUp)
        +recibirDaño(e: Enemigo)
        +aplicarPowerUps()
    }

   abstract StrategyState{
        +recibirDaño(pw: powerUp)
        +recibirDaño(pw: powerUp, pw: powerUp)
        +colisionarConBloque(pw: powerUp)
    }
    note left of Personaje::aplicarEfecto
    cambia el estado de mario 
    end note
    note left of Personaje::removerPowerUp
    cuando se remueve el power up tambien se remueve el estado de mario
    end note
    note left of Personaje::aplicarPowerUps
    se aplica cada power up en cada frame del juego segun sea necesario
    end note

    interface PowerUp {
        +activar(mario: Personaje)
        +desactivar(mario: Personaje)
    }
    note left of PowerUp::activar
      método activar en cada clase concreta de PowerUp contiene la lógica específica de ese power-up
    end note

    interface EstadoPersonaje{
        +recibirDano(personaje: Personaje)
    }

    class EstadoNormal{
    }

    class EstadoSuper{
        +romperBloque(plataforma: Plataforma);
    }

    class EstadoFlorDeFuego{
        +lanzarBolaDeFuego()
    }

    class Movible{
        +cambiarDireccion()
    }

    interface Enemigo { 
        +recibirDano() 
        +morir()
        +moverse() 
        +getPuntajeAlMatar(): int
    }

    class KoopaTroopa {
        #caparazon: Caparazon
        #escondido: Caparazon
        +setEscondio(bool: boolean)
        +getEscondido(): boolean

    } 

    class Goomba{
    }

    class Spiny { 
    }

    class Lakitu {
    }

    class BuzzyBeattle {
    }

    class PiranhaPlant {  
    }

    class Moneda {
    }

    abstract class PowerUp {
        +aplicar(mario: Personaje)
    }

    class FlorFuego{
    }

    class ChampinionVerde{
        +IncremetarVida()
    }

    class SuperChampinion{
    }

    class Estrella{
    }
    
    class Plataforma {
    }

    class Vacio {
    }

    class Tuberia {
        #pirania: PiranhaPlant
    }

    class BloqueSolido {
    }

    class BloquePregunta {
        #moneda: Moneda
        #powerUp: PowerUp
    }

    class LadrilloSolido {
        +destruir()
    }
    
    class Deslizable{
        +cambiarDireccion()
    }

    class Caparazon{
    }

    class Proyectil{
    }

    class BolaFuego {
    }

}

together {
    class CollisionsEngine <<Singleton>> {
        #{static} uniqueInstance: CollisionsEngine
        #nextCollidersToCheck: Collection<Collider>
        #chunks: [][]Collection<Collider>
        +{static} instance()
        #checkCollision(e1: Collider, e2: Collider)
        +registerToCheck(c: Collider)
        +setChunk(c: Collider, x: int, y: int)
    }
    note left of CollisionsEngine::checkCollision
        if (hayColision) {
            c2.collide(c1, d1);
            c1.collide(c2, d2);
        }
    end note

    interface Entidad {
        +update()
        +loaded(): boolean
        +load()
    }

    interface Collider {
        +getEntidad(): Entidad
        +collide(c: Collider, d: Direction)
        +handleCollision(c: Collider, d: Direction)
        +getPosition(p: Position)
        +setPosition(): Position
        +switch(b: boolean)
        +activated(): boolean
    }
    note left of Collider::collide
        c.handleCollision(this, d)
    end note

    interface ElementoGrafico {
        +draw()
        +getPosition(): Position
        +setPosition(p: Position)
        +getSprite(): Sprite
        +setSprite(s: Sprite)
    }

    class SpriteFactory {
        #possibleSprites: Collection<String>
        #loadedSprites: Map<String, Sprite>
        +getSprite(key: String)
        +getPossibleSprites(): Iterable<String>
    }

    class Sprite {
        #imagen : Image
        +draw(int x, int y)
        +setImagen(image : Image)
        +getImagen() : Image
    }

    class GraphicEngine {
        #ElementosGraficos: Collection<ElementoGrafico>
        +addElementoGrafico(e: ElementoGrafico)
        +drawFrame()
    }

    class LectorNiveles <<Singleton>> {
        +crearNivel(file: String): Nivel
    }

    class Posicion {
        #x: int
        #y: int
        +alterX(diff: int)
        +alterY(diff: int)
        +getX(): int
        +getY(): int
    }
}

enum Direccion {
    IZQUIERDA
    DERECHA
    ARRIBA
    ABAJO
}
@enduml
