@startuml
class Mario {
    #marioStates: List<MarioState>
    #brickCollisions: List<BrickCollision>
    #enemyCollisions: List<EnemyCollision>
    #graphicElement: GraphicElement
    #collider: Collider
    #position: Point
    #loaded: boolean
    #speedX: int
    #lifes: int
    +Mario(gE: GraphicElement, collider: Collider, 
    p: Point)
    +clone(): Entity
    +update()
    +updateScreenPosition(levelWidth: int)
    +jump()
    +die()
    +collide(b: SolidBrick)
    +collide(b: SolidBlock)
    +collide(e: Enemy)
    +getCollider(): Collider
    +getGraphicElement(): GraphicElement
    +addMarioState(s: MarioState)
    +removeMarioState(s: MarioState)
    +addEnemyCollision(c: EnemyCollision)
    +removeEnemyCollision(c: EnemyCollision)
    +addBrickCollision(c: BrickCollision)
    +removeBrickCollision(c: BrickCollision)
    +getMarioStates(): Iterable<MarioState>
    +setSpeedX(i: Int)
    +addLife()
}

interface BrickCollision <<Strategy>> {
    +collide(b: SolidBrick)
}

DefaultBrickCollision .u[hidden].|> BrickCollision
BreakBrickCollision .u[hidden].|> BrickCollision

interface EnemyCollision <<Strategy>> {
    +collide(e: Enemy)
}

DefaultEnemyCollision .u[hidden].|> EnemyCollision
SuperEnemyCollision .u[hidden].|> EnemyCollision
InvincibleEnemyCollision .u[hidden].|> EnemyCollision

together {
    class FireBallThrower <<Singleton>> {
        #{static} uniqueInstance: FireBallThrower
        +{static} instance(): FireBallThrower
        #mario: Mario
        +update()
    }

    class Croucher <<Singleton>> {
        #{static} uniqueInstance: Croucher
        +{static} instance(): Croucher
        #mario: Mario
        #crouched: boolean
        +getCrouch(): boolean
        +update()
    }
}

interface MarioState <<Command>> {
    +setState()
    +removeState()
}

Fire .u[hidden].|> MarioState
Invincible .u[hidden].|> MarioState
Super .u[hidden].|> MarioState

' FORMATTING
Mario -d[hidden]-> BrickCollision
Mario -d[hidden]-> EnemyCollision
Mario -d[hidden]-> MarioState
@enduml
