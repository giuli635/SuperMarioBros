@startuml
' TODO: crear los colisionadores de carga
' TODO: vincular los colisionadores de carga con el engine gr√°fico
'
class CollisionsEngine <<Singleton>> {
    #{static} uniqueInstance: CollisionsEngine
    #nextCollidersToCheck: Collection<Collider>
    #chunks: List<List<Collider>>
    +{static} instance(): CollisionsEngine
    #checkCollision(e1: Collider, e2: Collider): Direction
    +checkCollisions()
    +registerToCheck(c: Collider)
    +calculateChunk(c: Collider):int[]
    +addToChunk(ind: int, item: Collider)
    +removeFromChunk(item: Collider)
    +getChunk(ind: int):Iterable<Collider>
    +getAmountOfChunks():int
    +registerToCheck()
    +addToCheck(Collider c)
    +setChunk(c: Collider, x: int, y: int)
}
note right of CollisionsEngine::checkCollision
    if (hayColision) {
        c2.collide(c1, d1);
        c1.collide(c2, d2);
    }
end note

interface Entity {
    +update()
    +loaded(): boolean
    +load()
    +unload()
    +Clone(): entity
    +getGraphicElement(): GraphicElement
    +getCollider(): Collider
}

interface Collider {
    +getEntity(): Entity
    +handleCollision(c: Collider, d: Direction)
    +getLocation(): Point
    +setLocation(x: int, y: int)
    +getVelocity(): Vector2D
    +setActive(b: boolean)
    +activated(): boolean
}
note left of Collider::collide
    c.handleCollision(this, d)
end note

abstract class GameCollider {
    #hitbox: []int
    +handleCollision(c: MarioCollider, d: Direction)
    +handleCollision(c: EnemyCollider, d: Direction)
    +handleCollision(c: PlatformCollider, d: Direction)
    +handleCollision(c: CoinCollider, d: Direction)
    +handleCollision(c: PowerUpCollider, d: Direction)
    +handleCollision(c: FireBallCollider, d: Direction)
}

MarioCollider .u[hidden].|> GameCollider
EnemyCollider .u[hidden].|> GameCollider
PlatformCollider .u[hidden].|> GameCollider
CoinCollider .u[hidden].|> GameCollider
PowerUpCollider .u[hidden].|> GameCollider
FireBallCollider .u[hidden].|> GameCollider

interface GraphicElement {
    +getEntity(): Entity
    +translate(dx: int, dy: int)
    +draw()
    +getPosition(): Point
    +setPosition(p: Point)
    +setSprite(s: ImageIcon)
    +getSprite(): ImageIcon
    +getLabel(): JLabel
    +setSprite(s: Sprite)
}

class SpriteFactory <<Singleton>> {
    #{static} uniqueInstance: SpriteFactory
    +{static} instance(): SpriteFactory
    #possibleSprites: Collection<String>
    #loadedSprites: Map<String, Sprite>
    +getSprite(key: String)
    +getPossibleSprites(): Iterable<String>
}

class Sprite {
    #image : Image
    +Sprite(s: String)
    +draw(x: int, y: int)
    +setImage(image : Image)
    +getImage() : Image
}

class GraphicEngine <<Singleton>> {
    #{static} uniqueInstance: GraphicEngine
    #frame: JFrame
    #panel: JPanel
    #elements: Collection<GraphicElement>
    -GraphicEngine()
    +{static} instance(): GraphicEngine
    +addGraphicElement(e: GraphicElement)
    +removeGraphicElement(e: GraphicElement)
    +getPanelSize(): Dimension
    +scrollScreen(velocity: int)
    +drawFrame()
}

class Vector2D {
    #start: Point
    #end: Point
    #xComponent: double
    #yComponent: double
    +Vector2D(s: Point, e: Point)
    +getStart(): Point
    +getEnd(): Point
    +sum(v: Vector2D): Vector2D
    +getXComponent()
    +getYComponent()
}

enum Direction {
    LEFT
    RIGTH
    UP
    DOWN
}

' FORMATTING

Entity -d[hidden]-> GraphicElement
Entity -d[hidden]-> Collider
CollisionsEngine -l[hidden]-> Collider
GameCollider .u[hidden].|> Collider
GraphicEngine -r[hidden]-> GraphicElement
GraphicEngine -l[hidden]-> SpriteFactory
SpriteFactory -d[hidden]-> Sprite
@enduml
