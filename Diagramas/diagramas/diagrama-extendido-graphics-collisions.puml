@startuml
' TODO: crear los colisionadores de carga
' TODO: vincular los colisionadores de carga con el engine gr√°fico
'
class CollisionsEngine <<Singleton>> {
    #{static} uniqueInstance: CollisionsEngine
    #nextCollidersToCheck: Collection<Collider>
    #chunks: [][]Collection<Collider>
    +{static} instance(): CollisionsEngine
    #checkCollision(e1: Collider, e2: Collider): Direction
    +checkCollisions()
    +registerToCheck(c: Collider)
    +setChunk(c: Collider, x: int, y: int)
}
note right of CollisionsEngine::checkCollision
    if (hayColision) {
        c2.collide(c1, d1);
        c1.collide(c2, d2);
    }
end note

interface Entity {
    +update()
    +loaded(): boolean
    +load()
    +unload()
    +getGraphicElement(): GraphicElement
    +getCollider(): Collider
}

interface Collider {
    +getEntity(): Entity
    +collide(c: Collider, d: Direction)
    +handleCollision(c: Collider, d: Direction)
    +getLocation(): Point
    +setLocation(p: Point)
    +getVelocity(): Vector2D
    +checkCollision(c: Collider): Direction
    +setActive(b: boolean)
    +activated(): boolean
}
note left of Collider::collide
    c.handleCollision(this, d)
end note

abstract class GameCollider {
    #hitbox: []int
    +handleCollision(c: MarioCollider, d: Direction)
    +handleCollision(c: EnemyCollider, d: Direction)
    +handleCollision(c: PlatformCollider, d: Direction)
    +handleCollision(c: CoinCollider, d: Direction)
    +handleCollision(c: PowerUpCollider, d: Direction)
    +handleCollision(c: FireBallCollider, d: Direction)
}

MarioCollider .u[hidden].|> GameCollider
EnemyCollider .u[hidden].|> GameCollider
PlatformCollider .u[hidden].|> GameCollider
CoinCollider .u[hidden].|> GameCollider
PowerUpCollider .u[hidden].|> GameCollider
FireBallCollider .u[hidden].|> GameCollider

interface GraphicElement {
    +draw()
    +getPoint(): Point
    +setPoint(p: Point)
    +getSprite(): Sprite
    +setSprite(s: Sprite)
}

class SpriteFactory <<Singleton>> {
    #{static} uniqueInstance: SpriteFactory
    +{static} instance(): SpriteFactory
    #possibleSprites: Collection<String>
    #loadedSprites: Map<String, Sprite>
    +getSprite(key: String)
    +getPossibleSprites(): Iterable<String>
}

class Sprite {
    #image : Image
    +Sprite(s: String)
    +draw(x: int, y: int)
    +setImage(image : Image)
    +getImage() : Image
}

class GraphicEngine <<Singleton>> {
    #{static} uniqueInstance: GraphicEngine
    #elements: Collection<GraphicElement>
    -GraphicEngine()
    +{static} instance(): GraphicEngine
    +addGraphicElement(e: GraphicElement)
    +removeGraphicElement(e: GraphicElement)
    +drawFrame()
}

class Vector2D {

}

enum Direction {
    LEFT
    RIGTH
    UP
    DOWN
}

' FORMATTING

Entity -d[hidden]-> GraphicElement
Entity -d[hidden]-> Collider
CollisionsEngine -l[hidden]-> Collider
GameCollider .u[hidden].|> Collider
GraphicEngine -r[hidden]-> GraphicElement
GraphicEngine -l[hidden]-> SpriteFactory
SpriteFactory -d[hidden]-> Sprite
@enduml
